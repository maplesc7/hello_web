<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <meta name="apple-mobile-web-app-title" content="VaporClock" />
  <meta name="theme-color" content="#000000" />
  <title>VaporClock</title>
  <style>
    :root {
      /* Base colors */
      --bg-top: #0b1020;
      --bg-bottom: #05070d;
      --neon-a: #ff3ea5; /* magenta */
      --neon-b: #ffb200; /* orange */

      /* Typography */
      --clock-letter-spacing: -0.016em;
      --clock-glow-soft: 12px;
      --clock-glow-strong: 24px;

      /* Noise */
      --noise-opacity: 0.045;

      /* Visual viewport fallback */
      --app-h: 100dvh;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: linear-gradient(180deg, var(--bg-top) 0%, var(--bg-bottom) 100%);
      color: #fff;
      -webkit-text-size-adjust: 100%;
      overscroll-behavior: none;
    }

    /* App layout: header(clock) + stage(scene) */
    .app {
      position: relative;
      height: var(--app-h);
      width: 100%;
      display: grid;
      grid-template-rows: auto 1fr; /* [header] auto / [stage] 1fr */
      box-sizing: border-box;
      padding-left: env(safe-area-inset-left, 0px);
      padding-right: env(safe-area-inset-right, 0px);
      padding-bottom: env(safe-area-inset-bottom, 0px);
      touch-action: manipulation;
    }

    /* Header / Clock */
    .header {
      padding-top: max(env(safe-area-inset-top, 0px), 20px);
      margin-top: 2vh; /* 視覚的ゆとり */
      display: grid;
      place-items: center;
    }

    .clock {
      margin: 0 auto;
      font-family: -apple-system, system-ui, "SF Pro Display", "SF Pro Text", Inter, Roboto, "Helvetica Neue", Arial, sans-serif;
      font-weight: 600;
      /* 緑枠級に拡大（端末幅基準） */
      font-size: clamp(64px, 18vw, 120px);
      letter-spacing: var(--clock-letter-spacing);
      line-height: 1.04;
      background: linear-gradient(90deg, var(--neon-a), var(--neon-b));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow:
        0 0 1px rgba(255,255,255,0.22),
        0 0 var(--clock-glow-soft) color-mix(in oklab, var(--neon-a) 55%, transparent),
        0 0 var(--clock-glow-strong) color-mix(in oklab, var(--neon-b) 35%, transparent);
      user-select: none;
    }

    /* Stage (scene container) */
    .stage {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    /* Static noise overlay */
    .noise {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: var(--noise-opacity);
      mix-blend-mode: overlay;
    }

    /* Orientation hint (fallback) */
    .orientation-overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: #000;
      color: #fff;
      z-index: 10;
      font-family: -apple-system, system-ui, "SF Pro Text", Inter, Roboto, sans-serif;
    }
    @media (orientation: landscape) {
      .orientation-overlay { display: flex; }
    }

    /* Force dark appearance */
    @media (prefers-color-scheme: light) { :root { color-scheme: dark; } }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header class="header">
      <div class="clock" id="clock" aria-live="polite" aria-atomic="true">00:00</div>
    </header>
    <main class="stage" id="stage" aria-hidden="true">
      <!-- Static noise -->
      <svg class="noise" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true">
        <filter id="noiseFilter">
          <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="2" stitchTiles="stitch" />
          <feColorMatrix type="saturate" values="0" />
        </filter>
        <rect width="100%" height="100%" filter="url(#noiseFilter)" />
      </svg>
      <!-- Scene SVG (動的に中身を生成) -->
      <svg id="scene-svg" aria-hidden="true"></svg>
    </main>
  </div>
  <div class="orientation-overlay" aria-hidden="true">縦向きでご利用ください</div>

  <script>
    (function() {
      'use strict';

      // ===== Viewport height fallback (100dvh 対応外向け) =====
      const setAppHeight = () => {
        const h = (window.visualViewport && window.visualViewport.height) || window.innerHeight;
        document.documentElement.style.setProperty('--app-h', h + 'px');
      };
      setAppHeight();
      let vhTimer = null;
      const onVVChanged = () => { clearTimeout(vhTimer); vhTimer = setTimeout(setAppHeight, 100); };
      window.addEventListener('resize', onVVChanged);
      window.addEventListener('orientationchange', onVVChanged);
      document.addEventListener('visibilitychange', onVVChanged);

      // ===== Clock (minute-sync) =====
      const clockEl = document.getElementById('clock');
      const fmt = d => `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
      const updateClock = () => { clockEl.textContent = fmt(new Date()); };
      const scheduleMinuteSync = () => {
        updateClock();
        const now = new Date();
        const ms = (60 - now.getSeconds()) * 1000 - now.getMilliseconds();
        setTimeout(scheduleMinuteSync, Math.max(0, ms));
      };

      // ===== Scene drawing (SVG, real pixels) =====
      const sceneSvg = document.getElementById('scene-svg');
      function createSvg(tag, attrs) {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const k in attrs) el.setAttribute(k, attrs[k]);
        return el;
      }

      function drawScene() {
        // Clear
        while (sceneSvg.firstChild) sceneSvg.removeChild(sceneSvg.firstChild);
        // Size from stage
        const stage = document.getElementById('stage');
        const rect = stage.getBoundingClientRect();
        const W = Math.max(1, Math.floor(rect.width));
        const H = Math.max(1, Math.floor(rect.height));

        // Set SVG size & viewBox to real pixels (安定)
        sceneSvg.setAttribute('width', String(W));
        sceneSvg.setAttribute('height', String(H));
        sceneSvg.setAttribute('viewBox', `0 0 ${W} ${H}`);
        sceneSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

        // ===== Defs =====
        const defs = createSvg('defs', {});
        const grad = createSvg('linearGradient', { id: 'neonGrad', x1: '0%', y1: '0%', x2: '100%', y2: '0%' });
        grad.appendChild(createSvg('stop', { offset: '0%', 'stop-color': getCss('--neon-a') }));
        grad.appendChild(createSvg('stop', { offset: '100%', 'stop-color': getCss('--neon-b') }));
        const glow = createSvg('filter', { id: 'neonGlow', x: '-50%', y: '-50%', width: '200%', height: '200%' });
        glow.appendChild(createSvg('feGaussianBlur', { stdDeviation: '0.8', result: 'b1' }));
        glow.appendChild(createSvg('feGaussianBlur', { stdDeviation: '2.4', in: 'b1', result: 'b2' }));
        const merge = createSvg('feMerge', {});
        merge.appendChild(createSvg('feMergeNode', { in: 'b2' }));
        merge.appendChild(createSvg('feMergeNode', { in: 'SourceGraphic' }));
        glow.appendChild(merge);
        const gnd = createSvg('linearGradient', { id: 'groundGrad', x1: '0', y1: '0', x2: '0', y2: '1' });
        gnd.appendChild(createSvg('stop', { offset: '0%', 'stop-color': '#070a12' }));
        gnd.appendChild(createSvg('stop', { offset: '100%', 'stop-color': '#020308' }));
        defs.appendChild(grad); defs.appendChild(glow); defs.appendChild(gnd);
        sceneSvg.appendChild(defs);

        // ===== Ground =====
        const groundY = H * 0.55; // 背景の暗部の開始（控えめに上げる）
        sceneSvg.appendChild(createSvg('rect', { x: '0', y: String(groundY), width: String(W), height: String(H - groundY), fill: 'url(#groundGrad)' }));

        // ===== Road (vanish at 50% height) =====
        const vanishY = H * 0.5;
        const bottomY = H;
        const roadTopLeftX = W * 0.42;
        const roadTopRightX = W * 0.58;
        const roadBottomLeftX = W * 0.05;
        const roadBottomRightX = W * 0.95;

        const road = createSvg('polygon', {
          points: `${roadBottomLeftX},${bottomY} ${roadBottomRightX},${bottomY} ${roadTopRightX},${vanishY} ${roadTopLeftX},${vanishY}`,
          fill: '#05070d'
        });
        sceneSvg.appendChild(road);

        // Shoulders (neon)
        const leftShoulder = createSvg('polyline', {
          points: `${roadBottomLeftX},${bottomY} ${roadTopLeftX},${vanishY}`,
          fill: 'none', stroke: 'url(#neonGrad)', 'stroke-width': String(Math.max(0.8, W * 0.008)), filter: 'url(#neonGlow)'
        });
        const rightShoulder = createSvg('polyline', {
          points: `${roadBottomRightX},${bottomY} ${roadTopRightX},${vanishY}`,
          fill: 'none', stroke: 'url(#neonGrad)', 'stroke-width': String(Math.max(0.8, W * 0.008)), filter: 'url(#neonGlow)'
        });
        sceneSvg.appendChild(leftShoulder);
        sceneSvg.appendChild(rightShoulder);

        // Center dashed lines (static short segments)
        const centerX = W * 0.5;
        const dashW = Math.max(1, W * 0.006);
        const dashes = [
          [H * 0.95, H * 0.88],
          [H * 0.84, H * 0.77],
          [H * 0.73, H * 0.69]
        ];
        dashes.forEach(([y1, y2]) => {
          sceneSvg.appendChild(createSvg('polyline', {
            points: `${centerX},${y1} ${centerX},${y2}`,
            fill: 'none', stroke: 'url(#neonGrad)', 'stroke-width': String(dashW), filter: 'url(#neonGlow)'
          }));
        });

        // ===== Palm tree (top reaches 34% from top => bottom 66%) =====
        // Base model dimensions (local): width ≈ 90, height = 112 (top at 0, bottom at 112)
        const PALM_BASE_H = 112;
        const palmTopTargetY = H * 0.34; // 上から34%
        const s = (H - palmTopTargetY) / PALM_BASE_H; // scale so that bottom aligns with H
        const palmX = W * 0.78; // 右寄り
        const palmGroup = createSvg('g', { transform: `translate(${palmX}, ${H - PALM_BASE_H * s}) scale(${s})` });

        // Trunk (shadow)
        palmGroup.appendChild(createSvg('path', {
          d: 'M0,0 C2,20 2,60 1.2,80 C1,92 0,100 -0.6,112 L-4,112 C-3,96 -2,80 -2.6,68 C-3,56 -3,20 -1,0 Z',
          fill: '#030308'
        }));
        // Trunk neon edge
        palmGroup.appendChild(createSvg('path', {
          d: 'M0,0 C2,20 2,60 1.2,80 C1,92 0,100 -0.6,112',
          fill: 'none', stroke: 'url(#neonGrad)', 'stroke-width': '1.2', filter: 'url(#neonGlow)'
        }));
        // Leaves (shadow)
        const leafShadow = createSvg('g', { fill: 'none', stroke: '#04050a', 'stroke-width': '3' });
        ['M0,2 C18,-10 34,-12 50,-10',
         'M0,4 C16,-4 30,-6 44,-4',
         'M0,6 C12,0 24,2 36,6',
         'M0,8 C-10,2 -22,4 -34,10',
         'M0,10 C-14,0 -28,-2 -40,-2']
          .forEach(d => leafShadow.appendChild(createSvg('path', { d })));
        palmGroup.appendChild(leafShadow);
        // Leaves neon
        const leafNeon = createSvg('g', { fill: 'none', stroke: 'url(#neonGrad)', 'stroke-width': '0.9', filter: 'url(#neonGlow)' });
        ['M0,2 C18,-10 34,-12 50,-10',
         'M0,4 C16,-4 30,-6 44,-4',
         'M0,6 C12,0 24,2 36,6',
         'M0,8 C-10,2 -22,4 -34,10',
         'M0,10 C-14,0 -28,-2 -40,-2']
          .forEach(d => leafNeon.appendChild(createSvg('path', { d })));
        palmGroup.appendChild(leafNeon);

        sceneSvg.appendChild(palmGroup);
      }

      function getCss(varName) {
        return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
      }

      // ===== Wake Lock (best-effort) =====
      let wakeLock = null;
      async function requestWakeLock() {
        try {
          if ('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
            wakeLock.addEventListener && wakeLock.addEventListener('release', () => {});
          }
        } catch (_) {}
      }
      function setupWakeLock() {
        requestWakeLock();
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible' && wakeLock !== null) requestWakeLock();
        });
        window.addEventListener('pointerdown', () => requestWakeLock(), { passive: true });
      }

      // ===== Init =====
      window.addEventListener('load', () => {
        scheduleMinuteSync();
        setupWakeLock();
        drawScene();
      }, { once: true });
      window.addEventListener('resize', () => { onVVChanged(); drawScene(); });
      window.addEventListener('orientationchange', () => { onVVChanged(); drawScene(); });
    })();
  </script>
</body>
</html>
